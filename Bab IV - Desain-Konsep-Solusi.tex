% ==========================================
% BAB IV DESAIN KONSEP SOLUSI
% ==========================================

\chapter{DESAIN KONSEP SOLUSI}
\label{chap:desain-konsep-solusi}

Bab ini memaparkan rancangan konsep solusi yang diusulkan untuk menjawab permasalahan yang telah dianalisis pada bab sebelumnya. Berdasarkan hasil analisis pemilihan solusi, pendekatan yang digunakan dalam penelitian ini adalah pengembangan sistem eksperimen terotomatisasi berbasis konfigurasi. Pembahasan dalam bab ini mencakup desain konseptual eksperimen, perancangan arsitektur perangkat lunak atau \textit{evaluation pipeline}, serta spesifikasi implementasi data dan struktur berkas. Desain ini disusun untuk memenuhi kebutuhan fungsional terkait strukturisasi \textit{user persona} dan konsistensi eksekusi lintas model.
\section{Desain Konseptual Eksperimen}
\label{sec:desain-konseptual}

Bagian ini menjelaskan dasar konseptual dari sistem eksperimen yang dikembangkan untuk mengkaji pengaruh \textit{user persona} terhadap perilaku model bahasa. Desain konseptual ini berfungsi sebagai landasan arsitektur yang menghubungkan permasalahan metodologis pada Bab III dengan implementasi teknis yang dijelaskan pada Subbab~\ref{sec:perancangan-pipeline} dan Subbab~\ref{sec:implementasi-data}. Pendekatan yang digunakan menekankan pentingnya evaluasi yang terstruktur, terukur, dan bebas dari variasi input yang tidak relevan, sehingga setiap perubahan keluaran model dapat diinterpretasikan secara valid.

\subsection{Dekonstruksi Model Operasional Konvensional}
\label{subsec:existing-model}

Secara umum, praktik pengujian persona pada model bahasa masih banyak dilakukan menggunakan pendekatan manual atau semi-manual melalui \textit{conversational interface}. Pada pendekatan ini, persona dituangkan langsung ke dalam \textit{prompt} dan diberikan berulang-ulang setiap kali model diuji. Meskipun mudah diterapkan, pendekatan tersebut mengandung beberapa keterbatasan metodologis yang berdampak langsung pada validitas hasil eksperimen.

Keterbatasan pertama berkaitan dengan ketidakstabilan input atau \textit{input framing variance}. Penelitian sebelumnya menunjukkan bahwa model bahasa sangat sensitif terhadap variasi kecil pada redaksi instruksi, termasuk perubahan tanda baca, panjang kalimat, atau urutan penyampaian \parencite{turpin2023language, zhou2023largemodelsensitive}. Dalam skenario pengujian manual, variasi ini sulit dikendalikan sepenuhnya sehingga dapat menimbulkan perbedaan respons yang bukan berasal dari persona, tetapi dari ketidakteraturan input.

Keterbatasan kedua adalah minimnya \textit{observability}. Pengujian manual umumnya hanya menyimpan teks keluaran model, sedangkan informasi penting seperti \textit{latency}, jumlah token, atau struktur penalaran tidak tercatat. Hal ini menyulitkan analisis mengenai bagaimana persona memengaruhi beban komputasi atau pola respons model, sebagaimana disorot oleh Naous et al. \parencite{naous2025userlm}.

Keterbatasan ketiga adalah aspek reproduktibilitas. Karena interaksi dilakukan melalui antarmuka percakapan, sulit untuk menjamin bahwa percobaan yang sama dapat dijalankan ulang dengan kondisi yang benar-benar identik. Hal ini bertentangan dengan prinsip penelitian empiris yang menuntut transparansi dan konsistensi prosedur.

\subsection{Konstruksi Model Sistem Terotomatisasi}
\label{subsec:proposed-model}

Untuk mengatasi berbagai keterbatasan tersebut, penelitian ini mengusulkan model eksperimen terotomatisasi yang mengubah proses evaluasi dari pendekatan manual menjadi pendekatan berbasis data dan \textit{automated orchestration}. Desain konseptual ini bertumpu pada tiga pilar utama.

Pilar pertama adalah \textit{deterministic input configuration}. Setiap persona dan setiap pertanyaan benchmark diperlakukan sebagai objek data yang disimpan dalam format terstruktur. Pipeline menyusun instruksi secara programatik sehingga seluruh \textit{byte-level input} konsisten untuk setiap iterasi. Dengan cara ini, variabel independen benar-benar terbatas hanya pada variasi persona.

Pilar kedua adalah peningkatan \textit{data granularity}. Sistem merekam keluaran model beserta \textit{telemetry} seperti \textit{latency}, \textit{token usage}, dan jejak penalaran apabila tersedia. Informasi ini memungkinkan analisis lebih komprehensif terhadap dampak persona, termasuk aspek efisiensi komputasi dan kecenderungan struktur respons.

Pilar ketiga adalah \textit{scalable execution}. Mengingat jumlah kombinasi persona, model, dan butir soal yang besar, pipeline menerapkan eksekusi paralel dengan \textit{asynchronous processing}. Hal ini memungkinkan eksperimen diselesaikan dalam durasi yang lebih singkat tanpa mengorbankan konsistensi prosedural.

\subsection{Analisis Komparatif Metodologis}
\label{subsec:komparasi-metodologis}

Transformasi dari pendekatan manual menuju pipeline terotomatisasi membawa implikasi metodologis yang signifikan. Tabel berikut merangkum perbedaan utama antara kedua pendekatan dari beberapa dimensi analisis penting.

\begin{table}[htbp]
  \centering
  \caption{Perbandingan Validitas Metodologis antara Model Konvensional dan Model Terotomatisasi}
  \label{tab:komparasi-metodologis}
  \renewcommand{\arraystretch}{1.3}
  \begin{tabular}{p{3.8cm} p{5.2cm} p{5.2cm}}
    \toprule
    \textbf{Dimensi Analisis} &
    \textbf{Pendekatan Konvensional} &
    \textbf{Pendekatan Terotomatisasi} \\
    \midrule
    \textit{Input Control} &
    Rentan terhadap variasi redaksi instruksi dan ketidakkonsistenan manual. &
    Instruksi dirakit secara programatik sehingga konsisten pada seluruh iterasi. \\
    \midrule
    \textit{Data Granularity} &
    Hanya menyimpan teks keluaran. &
    Merekam \textit{latency}, token, dan metadata lainnya untuk analisis mendalam. \\
    \midrule
    \textit{Storage Format} &
    Tidak terstruktur dan sulit diproses ulang. &
    Menggunakan format JSON atau CSV yang siap dianalisis secara otomatis. \\
    \midrule
    \textit{Reproducibility} &
    Sulit menjamin kondisi eksperimen identik. &
    Seluruh parameter eksperimen terdokumentasi dan dapat diulang. \\
    \midrule
    \textit{Scalability} &
    Eksekusi linear dan memakan waktu. &
    Mendukung pemrosesan paralel berskala besar. \\
    \bottomrule
  \end{tabular}
\end{table}

Melalui perancangan ini, sistem eksperimen yang dikembangkan mampu menghasilkan data yang lebih stabil, konsisten, dan transparan. Dengan demikian, setiap perbedaan performa model dapat ditelusuri kembali secara lebih jelas ke persona yang sedang diuji.

%====== BAB IV.2 ======
\section{Perancangan Arsitektur Perangkat Lunak (\textit{Evaluation Pipeline})}
\label{sec:perancangan-pipeline}

Subbab ini menjelaskan desain arsitektur perangkat lunak yang digunakan untuk merealisasikan \textit{evaluation pipeline} sebagaimana dirumuskan pada Subbab~\ref{sec:desain-konseptual}. Arsitektur pipeline dirancang agar proses evaluasi dapat berjalan secara otomatis, konsisten, dan dapat direproduksi. Pendekatan ini memastikan bahwa setiap kombinasi persona, model, dan \textit{benchmark task} diuji dalam kondisi yang setara dan bebas dari variasi yang tidak diperlukan.

Pipeline yang dibangun bekerja sebagai rangkaian komponen yang saling berinteraksi: mulai dari pemuatan data, konstruksi instruksi, pengiriman permintaan ke model, hingga pencatatan \textit{telemetry}. Seluruh proses tersebut bekerja dalam satu alur terintegrasi sehingga sistem mampu menangani jumlah evaluasi yang besar secara stabil.

\subsection{Arsitektur Alur Kerja Sistem}
\label{subsec:arsitektur-alur-kerja}

Secara garis besar, \textit{evaluation pipeline} terbagi ke dalam empat komponen utama yang membentuk satu siklus pemrosesan yang berulang untuk setiap kombinasi persona dan butir soal. Keempat komponen tersebut adalah sebagai berikut.

\begin{enumerate}
    \item \textit{Configuration initialization and validation}.\\
    Tahap ini memuat seluruh konfigurasi sistem, definisi persona, dan \textit{benchmark dataset} ke dalam memori. Validasi struktur data dilakukan untuk memastikan bahwa setiap persona memiliki \textit{system instruction} yang lengkap dan setiap butir tugas memiliki pasangan pertanyaan dan jawaban acuan. Validasi awal ini penting untuk mencegah kesalahan format yang dapat menghentikan proses pada tahap berikutnya.

    \item \textit{Prompt construction engine}.\\
    Pada tahap ini, sistem membentuk dua jenis pesan: \textit{system message} yang berisi identitas persona dan \textit{user message} yang memuat pertanyaan dari benchmark. Penyusunan instruksi dilakukan menggunakan pola yang seragam untuk seluruh iterasi, sehingga setiap model menerima bentuk stimulus yang konsisten. Pendekatan ini menghilangkan variasi yang berasal dari perbedaan penulisan instruksi manual.

    \item \textit{Execution manager}.\\
    Komponen ini mengatur pengiriman permintaan ke model-model bahasa melalui \textit{API interface}. Untuk mengatasi volume permintaan yang besar, \textit{execution manager} menggunakan pendekatan eksekusi asinkron dengan \textit{I/O concurrency}. Permintaan diatur dalam \textit{task queue} dan dieksekusi dalam kelompok sesuai batas \textit{rate limit}. Strategi ini mempercepat proses pengujian tanpa melampaui kapasitas layanan penyedia model.

    \item \textit{Telemetry logger}.\\
    Komponen terakhir bertanggung jawab menyimpan seluruh respons model dalam format terstruktur, termasuk \textit{model output}, jumlah token, serta \textit{latency}. Data ini digunakan sebagai dasar analisis performa pada bab berikutnya.
\end{enumerate}

Dengan pembagian tersebut, pipeline dapat beroperasi secara modular namun tetap terpadu dalam satu alur pemrosesan.

\subsection{Algoritma Orkestrasi dan Konkurensi}
\label{subsec:algoritma-orkestrasi}

Jumlah kombinasi persona, model, dan \textit{benchmark tasks} menghasilkan volume permintaan yang sangat besar. Oleh karena itu, pipeline menerapkan mekanisme eksekusi asinkron untuk meningkatkan efisiensi pemrosesan.

Pipeline pertama-tama membangun sebuah \textit{task queue} yang berisi seluruh pasangan persona–soal. Selanjutnya, \textit{task queue} diproses dalam kelompok yang ukurannya ditentukan oleh kapasitas \textit{concurrency}. Ketika satu kelompok tugas sedang diproses, sistem dapat menyiapkan kelompok berikutnya. Dengan demikian, waktu pemrosesan total dapat ditekan mendekati $O(N/C)$, di mana $N$ adalah jumlah permintaan dan $C$ adalah kapasitas konkurensi.

Apabila terjadi kegagalan seperti \textit{timeout}, \textit{connection reset}, atau batas \textit{rate limit}, pipeline tidak langsung menghentikan seluruh proses. Sebaliknya, tugas tersebut dicatat dan dieksekusi ulang dengan \textit{exponential backoff}. Pendekatan ini membuat pipeline tetap stabil meskipun dijalankan dalam waktu yang panjang.

\subsection{Mekanisme Injeksi Konteks Persona}
\label{subsec:mekanisme-injeksi}

Mekanisme injeksi persona merupakan elemen penting untuk memastikan bahwa pengaruh persona dapat diukur dengan jelas. Pipeline menerapkan dua tahap injeksi konteks yang bersifat tetap dan hanya dilakukan satu kali untuk setiap persona sebelum evaluasi dimulai.

Tahap pertama adalah \textit{persona context initialization}. Pada tahap ini, sistem menyusun pesan awal yang merangkum identitas dan karakter persona. Pesan ini berfungsi membangun \textit{cognitive framing} awal pada model, baik untuk persona eksplisit maupun implisit. Tahap ini memastikan bahwa model berada dalam kondisi persona yang konsisten sebelum diberikan tugas.

Tahap kedua adalah \textit{persona warm-up message}. Pesan ini digunakan untuk memastikan bahwa model memberikan respons yang sesuai dengan identitas persona. Respons dari tahap ini tidak digunakan dalam evaluasi, tetapi berfungsi sebagai verifikasi bahwa proses injeksi berhasil.

Setelah kedua tahap ini selesai, pipeline tidak lagi mengulangi injeksi persona untuk setiap pertanyaan. Identitas yang telah ditanamkan pada awal percakapan tetap digunakan selama seluruh rangkaian pengujian. Model kemudian langsung memproses seluruh soal pada GSM8K dan MMLU-Redux dalam kondisi persona yang sama. Pendekatan ini memastikan bahwa variasi keluaran model berasal dari perbedaan persona, bukan dari perbedaan struktur instruksi.

\subsection{Mekanisme Toleransi Kesalahan dan Persistensi Status}
\label{subsec:toleransi-kesalahan}

Pipeline dirancang agar tetap stabil meskipun menghadapi gangguan selama proses pengujian. Dua mekanisme utama digunakan untuk menjamin integritas data dan keberlanjutan proses.

Pertama, sistem menerapkan \textit{state persistence}. Setelah setiap tugas berhasil diproses, status kemajuan dicatat sehingga apabila terjadi interupsi, pipeline dapat dilanjutkan kembali tanpa mengulangi tugas yang sudah selesai.

Kedua, gangguan sementara ditangani dengan \textit{error handling} berbasis penjadwalan ulang adaptif. Tugas yang gagal tidak langsung dihentikan, tetapi dijalankan kembali setelah jeda waktu tertentu. Dengan kombinasi kedua strategi ini, pipeline dapat menyelesaikan seluruh rangkaian evaluasi meskipun terjadi kendala jaringan atau batasan layanan eksternal.

%====== BAB IV.3 ======
\section{Implementasi Data, Struktur Berkas, dan Keluaran Pipeline}
\label{sec:implementasi-data}

Subbab ini menjelaskan bagaimana pipeline yang telah dirancang pada bagian sebelumnya terealisasi dalam bentuk struktur data, organisasi direktori, serta keluaran eksperimen yang dihasilkan. Implementasi ini berperan penting dalam memastikan bahwa seluruh proses pemuatan data, injeksi konteks, inferensi, pencatatan log, dan agregasi hasil berlangsung secara terstruktur, dapat ditelusuri, serta mendukung keterulangan eksperimen.

\subsection{Organisasi Direktori dan Artefak Data}

Struktur direktori disusun secara hierarkis untuk memisahkan fungsi-fungsi inti dalam pipeline. Empat komponen utama yang digunakan adalah sebagai berikut.

\begin{enumerate}
    \item \textit{Root directory}.  
    Berisi skrip pemanggil pipeline serta utilitas eksekusi.

    \item \textit{Configuration directory}.  
    Menyimpan konfigurasi model, kredensial layanan, dan parameter eksekusi.

    \item \textit{Input assets directory}.  
    Berisi definisi persona dan \textit{benchmark datasets} yang telah dinormalisasi.

    \item \textit{Results directory}.  
    Memuat log inferensi per butir soal dan tabel agregasi hasil dalam format terstruktur.
\end{enumerate}

Struktur ini memudahkan proses audit dan memastikan seluruh artefak eksperimen terdokumentasi dengan baik.

\subsection{Subsistem Perangkat Lunak dan Alur Transformasi Data}

Pipeline diimplementasikan melalui empat subsistem perangkat lunak yang berinteraksi secara berurutan:

\begin{enumerate}
    \item \textit{Execution orchestration subsystem}.  
    Bertugas membentuk \textit{task queue} yang memuat seluruh kombinasi model, persona, dan pertanyaan.

    \item \textit{Model communication subsystem}.  
    Mengelola pembentukan pesan, pengiriman \textit{prompt}, penanganan respons, serta batas layanan.

    \item \textit{Monitoring subsystem}.  
    Menyediakan mekanisme \textit{checkpointing} sehingga eksekusi dapat dilanjutkan setelah gangguan.

    \item \textit{Analysis subsystem}.  
    Mengolah log granular menjadi tabel hasil, termasuk perhitungan akurasi, penggunaan token, \textit{latency}, dan agregasi antar-persona.
\end{enumerate}

Transformasi data berlangsung dari log mentah → granular CSV → agregasi CSV → tabel ringkasan.

\subsection{Representasi Persona dan Injeksi Konteks}

Persona direpresentasikan dalam format terstruktur yang berisi identitas dan narasi. Representasi tersebut dikonversi menjadi \textit{system instruction} yang digunakan pada tahap injeksi konteks.

Injeksi konteks terdiri atas dua tahap tetap yang dilakukan satu kali untuk setiap persona:

\begin{enumerate}
    \item \textit{Persona grounding}, yaitu pengenalan identitas dan gaya naratif ke dalam konteks model.
    \item \textit{Warm-up interaction}, yaitu satu interaksi pemanasan untuk memastikan model merespons sesuai karakter persona.
\end{enumerate}

Setelah kedua tahap ini, pipeline mengirim seluruh pertanyaan GSM8K dan MMLU-Redux tanpa mengulang injeksi persona. Pendekatan ini memastikan bahwa pengaruh persona tetap konsisten sepanjang keseluruhan sesi.

\subsection{Contoh Log Inferensi}

Pipeline mencatat hasil inferensi dalam format terstruktur yang berisi metadata eksekusi, jawaban akhir, serta \textit{telemetry} penggunaan token dan latensi. Dua contoh berikut menunjukkan keluaran model tanpa \textit{reasoning trace} dan dengan \textit{reasoning trace}.

\subsubsection*{Log tanpa \textit{reasoning trace}}
\begin{figure}[htbp]
\begin{verbatim}
{
  "run": {"model_id": "example-model", "question_id": "gsm8k_00001"},
  "response": {
    "choices": [{"message": {"content": "Let's break down the problem..."}}],
    "usage": {"prompt_tokens": 211, "completion_tokens": 197}
  }
}
\end{verbatim}
\caption{Contoh log inferensi tanpa \textit{reasoning trace}}
\end{figure}

\subsubsection*{Log dengan \textit{reasoning trace}}
\begin{figure}[htbp]
\begin{verbatim}
{
  "run": {"model_id": "example-model-reasoning", "question_id": "gsm8k_00003"},
  "response": {
    "choices": [{
       "message": {
         "content": "Final answer: 70000",
         "reasoning": "First compute the purchase cost..."
       }}],
    "usage": {"completion_tokens": 867, "reasoning_tokens": 485}
  }
}
\end{verbatim}
\caption{Contoh log inferensi dengan \textit{reasoning trace}}
\end{figure}

\subsection{Ringkasan Hasil Eksperimen (Full Table)}

Ringkasan hasil eksperimen GSM8K untuk keseluruhan model dan persona ditampilkan pada Tabel~\ref{tab:full-gsm8k-progress}.  
Tabel ini menunjukkan perbandingan performa lintas model pada metrik akurasi, penggunaan token, dan \textit{latency}.

\begin{landscape}
\begin{table}[htbp]
\centering
\caption{Ringkasan Hasil Eksperimen GSM8K untuk Seluruh Model dan Persona}
\label{tab:full-gsm8k-progress}
\renewcommand{\arraystretch}{1.22}
\small

\begin{tabular}{l l 
                c c c 
                c c c
                c c c 
                c c c}
\toprule
\textbf{Model} & 
\textbf{Persona} &
\textbf{Total Q} &
\textbf{Correct} &
\textbf{Accuracy (\%)} &
\textbf{Total Prompt T.} &
\textbf{Total Compl. T.} &
\textbf{Total Tokens} &
\textbf{Total Reas. T.} &
\textbf{Avg Prompt T.} &
\textbf{Avg Compl. T.} &
\textbf{Avg Total T.} &
\textbf{Avg Reas. T.} &
\textbf{Avg Latency (s)} \\
\midrule

Bert Nebulon Alpha & man\_implicits &
610 & 593 & 97.21 &
125551 & 159699 & 285250 &
0 &
20582/610 & 2618/610 & 46762/610 &
0 &
10.481 \\
    
Bert Nebulon Alpha & woman\_implicits &
641 & 627 & 97.26 &
17138 & 163670 & 335208 &
0 &
26922/641 & 2552/641 & 52986/641 &
0 &
8.309 \\
\midrule

Grok 4.1 Fast & man\_implicits &
1315 & 1242 & 94.45 &
461404 & 863825 & 1325229 &
634958 &
49378/1315 & 65725/1315 & 100755/1315 &
634958/1315 &
9.591 \\

Grok 4.1 Fast & woman\_implicits &
1316 & 1254 & 95.36 &
538871 & 844065 & 1422736 &
671910 &
50827/1316 & 64100/1316 & 108132/1316 &
671910/1316 &
9.487 \\
\midrule

Nvidia Nemotron-nano-12B-v2-VL & man\_implicits &
1305 & 1224 & 93.79 &
268984 & 887065 & 1156049 &
0 &
20692/1305 & 67755/1305 & 133374/1305 &
0 &
24.432 \\

Nvidia Nemotron-nano-12B-v2-VL & woman\_implicits &
1315 & 1248 & 94.98 &
356096 & 1634188 & 1986284 &
0 &
26327/1315 & 124271/1315 & 151199/1315 &
0 &
29.149 \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}

\subsection{Contoh Ringkasan Satu Model}

Untuk mempermudah interpretasi, Tabel berikut menampilkan contoh ringkasan singkat untuk satu model, yaitu Grok~4.1 Fast.

\begin{table}[htbp]
\centering
\caption{Contoh Ringkasan Hasil untuk Model Grok 4.1 Fast}
\label{tab:grok41-example}
\renewcommand{\arraystretch}{1.25}
\small
\begin{tabular}{l c c c c c}
\toprule
\textbf{Persona} & 
\textbf{Total Q} &
\textbf{Correct} &
\textbf{Accuracy (\%)} &
\textbf{Avg Tokens} &
\textbf{Avg Latency (s)} \\
\midrule
man\_implicits   & 1315 & 1242 & 94.45 & 100755/1315 & 9.591 \\
woman\_implicits & 1316 & 1254 & 95.36 & 108132/1316 & 9.487 \\
\bottomrule
\end{tabular}
\end{table}

Kedua tabel ini menjadi dasar untuk analisis performa dan karakteristik respons model yang dibahas lebih lanjut pada Bab~V.
